<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\OxyPlot.dll" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\Horker.PSOxyPlot.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="OxyPlot" #>
<#@ import namespace="OxyPlot.Series" #>
<#@ import namespace="Horker.PSOxyPlot" #>
<#@ import namespace="Horker.PSOxyPlot.SeriesBuilders" #>
<#@ include file="Common.tt" #>
<#
var assembly = typeof(LineSeriesBuilder).Assembly;
var builderTypes = assembly.DefinedTypes.Where(x => x.Name.EndsWith("SeriesBuilder") && !x.IsAbstract && !x.Name.Contains("Function"));

// Uncomment this line to skip template generating.
// builderTypes = new TypeInfo[0];
#>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Management.Automation;
using OxyPlot;
using OxyPlot.Series;
using Horker.PSOxyPlot.SeriesBuilders;
using Horker.PSOxyPlot.ObjectFactories;

namespace Horker.PSOxyPlot
{
<#
foreach (var builderType in builderTypes)
{
    var builderInstance = builderType.AsType().GetConstructor(new Type[0]).Invoke(new object[0]);
    var baseType = builderType.BaseType;
    var seriesType = baseType.GenericTypeArguments[0];

    var name = seriesType.Name;
    var pointItemNames = (string[])builderType.GetMethod("get_DataPointItemNames").Invoke(builderInstance, null);
    var pointItemMandatoriness = (bool[])builderType.GetMethod("get_DataPointItemMandatoriness").Invoke(builderInstance, null);
    var aliases = "\"" + string.Join("\", \"", (string[])builderType.GetMethod("get_Aliases").Invoke(builderInstance, null)) + "\"";

    var pointItemTypes = baseType.GenericTypeArguments.Where((x, i) => i >= 2).Select(t => TypeAdaptorHelper.GetAdaptorType(t)).ToArray();
    var itemCount = pointItemNames.Length;
#>
    [Cmdlet("New", "Oxy<#= name #>")]
    [Alias(<#= aliases #>)]
    [OutputType(typeof(SeriesInfo<<#= name #>>))]
    public class NewOxy<#= name #> : PSCmdlet
    {
        [Parameter(Position = 0, Mandatory = false, ValueFromPipeline = true)]
        public PSObject InputObject;

<#
    int position = 1;
    for (var i = 0; i < itemCount; ++i)
    {
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string <#= pointItemNames[i] #>Name = "<#= pointItemNames[i] #>";

<#
    }
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string GroupName = null;

<#
    for (var i = 0; i < itemCount; ++i)
    {
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= pointItemTypes[i] #>[] <#= pointItemNames[i] #>;

<#
    }
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public object[] Group = null;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public PlotModel AddTo = null;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string OutFile = null;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public int OutWidth = 800;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public int OutHeight = 600;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public SwitchParameter SvgIsDocument = false;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public SwitchParameter PassThru = false;

<#
    foreach (var prop in EnumerateProperties(seriesType))
    {
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= prop.TypeName #> <#= prop.Name #>;

<#
    }
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string AxType;

<#
    foreach (var prop in AxisProperty.Enumerate())
    {
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= prop.TypeName #> Ax<#= prop.Name #>;

<#
    }
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string AyType;

<#
    foreach (var prop in AxisProperty.Enumerate())
    {
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= prop.TypeName #> Ay<#= prop.Name #>;

<#
    }
#>
        private <#= name #>Builder _builder;

        private void AssignParameters(<#= name #> series, Dictionary<string, object> bp)
        {
<#
    foreach (var prop in EnumerateProperties(seriesType))
    {
#>
            if (bp.ContainsKey("<#= prop.Name #>")) series.<#= prop.Name #> = <#= prop.ConversionString #>;
<#
    }
#>
        }

        protected override void BeginProcessing()
        {
            _builder = new <#= name #>Builder();
            _builder.ReadBoundParameters(MyInvocation.BoundParameters);
        }

        protected override void ProcessRecord()
        {
            // ProcessRecord is called once when InputObject is not given at all.
            if (InputObject == null)
                return;

            _builder.ReadPSObject(InputObject);
        }

        protected override void EndProcessing()
        {
            var si = _builder.CreateSeriesInfo();

            var bp = MyInvocation.BoundParameters;
            foreach (var s in si.Series)
                AssignParameters(s, bp);

            PlotModel model = AddTo;
            if (model == null && bp.ContainsKey("OutFile"))
                model = ObjectFactory.CreatePlotModel(si, bp);

            if (model != null)
            {
                foreach (var s in si.Series)
                    model.Series.Add(s);

                if (bp.ContainsKey("OutFile"))
                {
                    ModelExporter.Export(model, OutFile, OutWidth, OutHeight, SvgIsDocument);
                    if (!PassThru)
                        return;
                }

                WriteObject(model);
            }
            else
                WriteObject(si);
        }
    }

<#
}
#>
}
