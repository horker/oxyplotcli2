<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\OxyPlot.dll" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\Horker.PSOxyPlot.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="OxyPlot" #>
<#@ import namespace="OxyPlot.Series" #>
<#@ include file="Common.tt" #>
<#@ include file="Definitions.tt" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Management.Automation;
using OxyPlot;
using OxyPlot.Series;

namespace Horker.PSOxyPlot
{
<#
foreach (var def in SeriesDefinition.Series)
{
	var name = def.Type.Name;
#>
    [Cmdlet("New", "Oxy<#= name #>")]
    [Alias("oxy.<#= def.ShortName #>")]
    [OutputType(typeof(<#= name #>))]
    public class NewOxy<#= name #> : PSCmdlet
    {
        [Parameter(Position = 0, Mandatory = true, ValueFromPipeline = true)]
        public PSObject InputObject;

<#
	int position = 1;
	var pointDefs = def.PointDefinitions;
	foreach (var pd in pointDefs)
	{
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string <#= pd.Name #>Name = "<#= pd.Name #>";

<#
	}
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string GroupName = null;

<#
	foreach (var pd in pointDefs)
	{
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= pd.Type #>[] <#= pd.Name #>;

<#
	}
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public object[] Group = null;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public PlotModel AddTo = null;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public string OutFile = null;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public int OutWidth = 800;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public int OutHeight = 600;

        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public SwitchParameter SvgIsDocument = false;

<#
	foreach (var prop in EnumerateProperties(def.Type, Definitions.TypeAdaptors))
	{
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= prop.TypeName #> <#= prop.Name #>;

<#
	}
#>
        private <#= name #>Builder _builder;

		private void AssignParameters(<#= name #> series, Dictionary<string, object> bp)
		{
<#
	foreach (var prop in EnumerateProperties(def.Type))
	{
#>
			if (bp.ContainsKey("<#= prop.Name #>")) series.<#= prop.Name #> = <#= prop.Name #>;
<#
	}
#>
		}

        protected override void BeginProcessing()
        {
			_builder = new <#= name #>Builder(MyInvocation.BoundParameters);
        }

        protected override void ProcessRecord()
        {
			// ProcessRecord is called once when InputObject is not given at all.
			if (InputObject == null)
				return;

			_builder.ReadPSObject(InputObject);
        }

        protected override void EndProcessing()
        {
			var bp = MyInvocation.BoundParameters;

			PlotModel model = AddTo;
			if (model == null && bp.ContainsKey("OutFile"))
				model = new PlotModel();

			var series = _builder.CreateSeries();

			foreach (var s in series)
				AssignParameters(s, bp);

			if (model != null)
			{
				foreach (var s in series)
					model.Series.Add(s);
			}
			else
			{
				foreach (var s in series)
					WriteObject(s);
			}

			if (bp.ContainsKey("OutFile"))
				ModelExporter.Export(model, OutFile, OutWidth, OutHeight, SvgIsDocument);
        }
    }

<#
}
#>
}