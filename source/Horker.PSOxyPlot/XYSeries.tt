<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\OxyPlot.dll" #>
<#@ assembly name="$(ProjectDir)..\bin\Debug\Horker.PSOxyPlot.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="OxyPlot" #>
<#@ import namespace="OxyPlot.Series" #>
<#@ include file="Common.tt" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Management.Automation;
using OxyPlot;
using OxyPlot.Series;

namespace Horker.PSOxyPlot
{
<#
var seriesDefs = new SeriesDefinition[]
{
	new SeriesDefinition(typeof(LineSeries), "line", "DataPoint"),
	new SeriesDefinition(typeof(ScatterSeries), "scat", "ScatterPoint")
};

foreach (var def in seriesDefs)
{
	var name = def.Type.Name;
#>
    [Cmdlet("New", "Oxy<#= name #>")]
    [Alias("oxy.<#= def.ShortName #>")]
    [OutputType(typeof(<#= name #>))]
    public class NewOxy<#= name #> : PSCmdlet
    {
        [Parameter(ParameterSetName = "ByPipeline", Position = 0, Mandatory = true, ValueFromPipeline = true)]
        public PSObject InputObject;

        [Parameter(ParameterSetName = "ByPipeline", Position = 1, Mandatory = true)]
        public string XName = "X";

        [Parameter(ParameterSetName = "ByPipeline", Position = 2, Mandatory = true)]
        public string YName = "Y";

        [Parameter(ParameterSetName = "ByPipeline", Position = 3, Mandatory = false)]
        public string GroupName = null;

        [Parameter(ParameterSetName = "ByArray", Position = 0, Mandatory = true)]
        public double[] X = null;

        [Parameter(ParameterSetName = "ByArray", Position = 1, Mandatory = true)]
        public double[] Y = null;

        [Parameter(Position = 4, Mandatory = false)]
        public PlotModel AddTo = null;

        [Parameter(Position = 5, Mandatory = false)]
        public string OutFile = null;

        [Parameter(Position = 6, Mandatory = false)]
        public int OutWidth = 800;

        [Parameter(Position = 7, Mandatory = false)]
        public int OutHeight = 600;

        [Parameter(Position = 8, Mandatory = false)]
        public SwitchParameter SvgIsDocument = false;

<#
	var position = 9;
	foreach (var prop in EnumerateProperties(def.Type, TypeAdaptors.TYPE_ADAPTORS))
	{
#>
        [Parameter(Position = <#= position++ #>, Mandatory = false)]
        public <#= prop.TypeName #> <#= prop.Name #>;

<#
	}
#>
        private Dictionary<string, List<Tuple<double, double>>> _points;

		private static readonly string DEFAULT_GROUP_NAME = "no groups!!??#$%__";

        protected override void BeginProcessing()
        {
			if (X != null && X.Length != Y.Length)
				throw new ArgumentException("Arguments X and Y should have the same lengths");

            _points = new Dictionary<string, List<Tuple<double, double>>>();
        }

        protected override void ProcessRecord()
        {
			// ProcessRecord is called once when InputObject is not given.
			if (InputObject == null)
				return;

	        string group = DEFAULT_GROUP_NAME;
            if (!string.IsNullOrEmpty(GroupName))
            {
                var g = InputObject.Properties.Match(GroupName);
                if (g.Count > 0)
                    group = g[0].Value.ToString();
            }

			List<Tuple<double, double>> list;
			if (!_points.TryGetValue(group, out list))
			{
				list = new List<Tuple<double, double>>();
				_points.Add(group, list);
			}

			var x = SmartConverter.ToDouble(InputObject.Properties[XName].Value);
			var y = SmartConverter.ToDouble(InputObject.Properties[YName].Value);
            list.Add(Tuple.Create(x, y));
        }

        protected override void EndProcessing()
        {
			var bp = MyInvocation.BoundParameters;

			PlotModel model = AddTo;
			if (model == null && bp.ContainsKey("OutFile"))
				model = new PlotModel();

			if (_points.Count == 0 && X != null)
				_points.Add(DEFAULT_GROUP_NAME, new List<Tuple<double, double>>());

			foreach (var entry in _points)
			{
				var series = new <#= name #>();
				if (entry.Key != DEFAULT_GROUP_NAME)
					series.Title = entry.Key;

<#
	foreach (var prop in EnumerateProperties(def.Type))
	{
#>
				if (bp.ContainsKey("<#= prop.Name #>")) series.<#= prop.Name #> = <#= prop.Name #>;
<#
	}
#>

				foreach (var p in entry.Value)
					series.Points.Add(new <#= def.PointType #>(p.Item1, p.Item2));

				if (X != null)
				{
					for (var i = 0; i < X.Length; ++i)
						series.Points.Add(new <#= def.PointType #>(X[i], Y[i]));
					X = Y = null;
				}

				if (model != null)
					model.Series.Add(series);
				else
					WriteObject(series);
			}

			if (bp.ContainsKey("OutFile"))
				Exporter.Export(model, OutFile, OutWidth, OutHeight, SvgIsDocument);
        }
    }

<#
}
#>
}
<#+
class SeriesDefinition
{
	public Type Type;
	public string ShortName;
	public string PointType;
	public SeriesDefinition(Type type, string shortName, string pointType)
	{
		Type = type;
		ShortName = shortName;
		PointType = pointType;
	}
}
#>
